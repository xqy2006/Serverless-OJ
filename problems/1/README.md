## 题目描述

给定一个数列 $a_1\dots a_n$ 。 $a$ 数组可以修改，某些时刻我们会对原数组 $a$ 的第 $x$ 个元素改成 $v$。

我们想对 $a$ 数组排序。

排序有很多算法，在这里我们使用冒泡排序，下面是冒泡排序的一个样例：

```cpp
for(int i=1;i<n;++i)
for(int j=n;j>i;--j)
if(a[j]<a[j-1]) swap(a[j-1],a[j]);
```

对于排序后，会得到一个新数组，而我们想要知道某些位置的元素在排序后的位置，保证这种操作不超过 5000 次。

注意，排序操作不保留，修改针对的是排序前的数组。

## 输入格式

第一行两个整数 $n,q$ ，表示 $a$ 的长度和操作次数。

第二行有 $n$ 个整数，表示 $a_1\dots a_n$。

接下来的 $q$ 行，每一行有以下两种情况之一。

	 1 x v :表示一次修改操作。
	 2 x ：表示一次对原数组第 x 个元素的查询操作。

## 输出格式

对于每次操作 2，输出一个整数表示其在排序后的数组中是第几个元素。

## 样例

### 样例输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 样例输出

```
1
1
2
```

## 提示

对于所有测试数据，满足 $1≤n≤8000，1\le Q\le 2*10^5，1\le x\le n,1\le v,a_i\le 10^9$

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 5000 次操作属于类型一。

##### 提示

  1s 计算机能进行的运算大概是 $10^9$ ，为什么会给一个类型一的操作数量限制？

  C++ 中有自带的 sort 函数，可以将数组排序，用法为 sort(begin,end)，begin和end为头指针和尾指针的下一位，比如对 a1~n 排序时，使用 sort(a+1,a+1+n) 可以将其排序。sort的复杂度为 nlogn
